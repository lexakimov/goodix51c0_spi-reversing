PSK (Pre-Shared Key - Предварительно разделенный ключ)

PMK (Pairwise Master Key - Попарный мастер-ключ)
	генерируется (часто выводится) из PSK.
	сам по себе обычно не используется для шифрования данных напрямую.
	Вместо этого он служит основой для генерации других, более короткоживущих сеансовых ключей (например, PTK - Pairwise Transient Key).

- узнать алгоритм хеширования при write 0xbb010003 -> read 0xbb020003
- узнать алгоритм psk -> psk wb - смотреть production_write_key в коде драйвера

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CODEX

PSK Цепочка
- MCU сразу сообщает psk_check_fail:1, поэтому драйвер запускает процедуру “production process / check psk if valid” (logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace_clear.log:129,190,194,198).
- Первая проверка ищет зашифрованный PSK в Goodix_Cache.bin, но читает 0 байт, затем пытается запросить тип 0xbb010002 у MCU и получает отказ ret 0x200004 (…:206,211,244,247).
- Вторая попытка повторяет те же действия и завершается тем же кодом ошибки, подтверждая отсутствие валидного ключа и на хосте, и в контроллере (…:251,259,264,297,300).
- После двух неудач драйвер объявляет, что нужен новый PSK, и переходит к процедуре генерации/записи (. write psk to mcu) (…:303,305).

Генерация PSK
- Драйвер получает криптоконтекст Windows, генерирует 8‑байтный seed и 32‑байтный PSK (CryptAcquireContext succeeded, Random sequence generated) (…:307-313).
- PSK шифруется через DPAPI: “seal psk” даёт 324-байтный blob, внутри которого виден GUID и строка описания This is the description string. (…:314,317,332,333).
- Дополнительно формируется блок типа 0xbb010003 (102 байта), оба TLV (332 байта + 102 байта) пакуются в сообщение длиной 0x1c4 и отправляются на MCU командой cmd0 0xe (…:319-323,330-344,360).
- После подтверждения от MCU кеш с ключом обновлён, драйвер фиксирует успех и сообщает update key success (…:360,374,377).

Повторная проверка
- Сразу после записи выполняется новый check psk: теперь Goodix_Cache.bin читается полностью (332 байта), blob расшифровывается (unseal return 0x0) и из него вычисляется хэш (…:385,389-396,398).
- Для сверки MCU отдаёт хэш по data_type 0xbb020003; устройство возвращает 40 байт данных без ошибок (…:402,414-428).
- Сравнение хэшей проходит успешно (!!!hash equal !!!, check psk: psk is valid!), процесс помечается как завершённый (…:432-436).
- Позже состояние MCU показывает psk_check_fail:0, что подтверждает синхронизацию ключа между хостом и контроллером (…:1057).

------------------------------------

1. Да, параметр entropy_len 48 явно указан драйвером как при шифровании (seal psk, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace_clear.log:314-317), так и при расшифровке (generate rootkey, inbuf_len 324, entropy_len 48, там же :389-392). Это подсказка, что в CryptProtectData/CryptUnprotectData используется дополнительная 48-байтовая «entropy» (скорее всего аппаратно-зависимая соль).
2. GUID и строка описания видны в выгружаемых по SPI байтах того же блока: строки write 456 показывают UTF-16-LE текст This is the description string. внутри TLV, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace_clear.log:332-336. Непосредственно перед текстом лежит структура DPAPI с GUID’ом (d0 8c 9d df ...).
3. TLV — это формат «Type-Length-Value»: 4-байтовый идентификатор типа, 4-байтовая длина полезной нагрузки и затем сами данные. В посылке на MCU сначала идёт TLV 0xbb010002 (332 байта), далее TLV 0xbb010003 (102 байта), что видно по последовательности в тех же строках :329-357.
4. Блок 0xbb010003 появляется после шага process encrypted psk (process ret 0x0 type 0xbb010003, length before 32, length after:102, :318-319). При повторной проверке та же структура восстанавливается из файла как результат .wb data (wb return 0x0 length before 32, length after:102, :393-394), а затем из 102 байт вычисляется 32-байтовый хэш (.hash ... length after:32, :395-396). MCU читает этот хэш своим запросом 0xbb020003 и выдаёт 40 байт (заголовок + 32 байта значения, :402-419). Поэтому запись 0xbb010003 определяет, что MCU сохранит и вернёт при чтении 0xbb020003: если 102-байтовый блок другой, MCU-сохраняемый хэш меняется, и сравнение (шаг 3.verify) даст расхождение.
5. DPAPI используется только для хранения ключа на стороне хоста: seal psk шифрует 32-байтовый PSK перед записью в Goodix_Cache.bin, а unseal return 0x0 возвращает его в чистом виде (32 байта, :392). После расшифровки драйвер сразу делает .wb data/.hash, а затем запускает TLS (TLS Init Success, :647). Это означает, что полученный plaintext-PSK подается в mbedTLS (вероятно через mbedtls_ssl_conf_psk), а параллельно через TLV 0xbb010003 передаётся MCU. Контроллер, получив этот блок, обновляет свою копию ключевого материала и выдаёт согласованный хэш через 0xbb020003, так что обе стороны используют один и тот же PSK в последующем рукопожатии TLS-PSK.

но ведь длина bb010003 102 байта, а не 32. То есть PSK передается не в открытом виде? что значит .wb data и .hash ?

Блок 0xbb010003 действительно 102 байта. Это результат шага production_get_host_psk_data: на вход подаются 32 байта «чистого» PSK, на выход — структура большего размера.
Она содержит сам PSK (он лежит в первых 32 байтах) плюс добавочные поля/метаданные, которые Goodix добавляет перед отправкой на MCU.
То есть ключ в итоге уходит на устройство не только в DPAPI-обёртке из 0xbb010002, но и в практически открытом виде внутри 0xbb010003.

Лог Goodix>>> .wb data относится к функции production_get_host_psk_data (см. строки ...production_get_host_psk_data:02827). По сообщениям видно, что на вход она получает 32 байта и расширяет их до 102 (length before 32, length after:102). Судя по названию, это «white-box data»/«wrap blob» — упаковка ключа вместе с дополнительной служебной информацией для ПО/MCU.
Следующий шаг Goodix>>> .hash берёт эти 102 байта и считает по ним 32-байтовый хэш (length after:32). Именно этот хэш позже сравнивают с тем, что выдаёт контроллер по запросу 0xbb020003, чтобы убедиться, что хост и MCU синхронизировали один и тот же PSK.
Если хочется убедиться в присутствии самого ключа в блоке — можно посмотреть первые 32 байта полезной нагрузки 0xbb010003 (например, по логу: fa d1 e5 b8 79 30 26 5d ...). Они и являются тем самым PSK, а оставшиеся ~70 байт — служебные данные, позволяющие драйверу и MCU согласованно его хранить и валидировать.

------------------------------------

Термины

PSK — предварительно общий ключ (Pre-Shared Key). В логах генерируется заново (32 байта), шифруется через DPAPI и используется драйвером как идентификатор в TLS‑профиле TLS-PSK-WITH-AES-128-GCM-SHA256; см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:684.
PMK — парный мастер‑ключ (Pairwise Master Key). В стекe Goodix это производное значение/хэш от PSK, которым MCU и хост проверяют синхронность секретов; видно по сообщениям вида “Enclave decrypted PMK” в других логах (logs_3/WBDI.log:5106).
MCU — микроконтроллер внутри модуля отпечатка, на который драйвер шлёт SPI‑команды вида production_read_mcu/production_write_mcu; пример диалога см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:213.
nav base — эталонный (базовый) образ для режима навигации по поверхности сенсора; запрашивается в процедуре gf_get_navbase, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:1110.
fdt base — эталонные данные для режима FDT; драйвер загружает их через gf_get_fdtbase, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:1071.
nav — режим сенсора, в котором он выдаёт специальные “navigation” кадры (для жестов/позиционирования); переключение на него видно в logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:1110.
fdt — набор процедур и данных для Finger Detection Template (обработка и анализ кадров для обнаружения пальца); инициализация показана строками FDT_Init и startfdtDataAnalyzeMonitoring в logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:41 и logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:526.
evk — строка версии прошивки MCU (Evk version) формата GF_HC460SEC_APP_xxxxx; запрос выполняется GetEvkVersion, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:179.
HDSC firmware — вспомогательная прошивка (High-Definition/Security Controller) для внутреннего контроллера Goodix; необходимость обновления отмечена в logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:180.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Расшифровка:
Прямой путь — на Windows использовать CryptUnprotectData, передав бинарный blob и ту же энтропию.
Примеры:
    PowerShell: [System.Security.Cryptography.ProtectedData]::Unprotect($blob, $entropy, 'CurrentUser').
    Python с pywin32: win32crypt.CryptUnprotectData(blob, None, entropy, None, None, 0).

Если доступа к исходной системе нет, остаётся brute-force DPAPI через резервные ключи домена/DPAPI master key
(инструменты вроде mimikatz dpapi::masterkey или dpapick) — без них расшифровать нельзя, т.к. DPAPI использует AES‑256 с ключами, зависящими от SID пользователя и мастер‑ключей Windows.

После CryptUnprotectData вы получите исходный 32‑байтовый PSK, который далее используется как ввод для хэширования и TLS‑PSK‑handshake.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

1. генерим PSK - 32 байта
2. шифруем PSK в gf_seal_data через CryptProtectData - на выходе 324 байта (это sealed_psk (0xbb010002), хранится в Goodix_Cache.bin (332 байта))
3. преобразуем PSK в PSK WB (0xbb010003) через функцию production_write_key - на выходе 102 байта
4. записываем с помощью команды `0xe0` - 452 байта

0xbb010002 - write_sealed_psk (содержимое Goodix_Cache.bin)
длина 332 байта
	01 00 00 00 d0 8c 9d df 01 15 d1 11 8c 7a 00 c0 4f c2 97 eb 01
	00 00 00 4c 9c e6 7c 50 c6 b0 4b b6 37 cd 1c 72 51 14 ee 04 00 00 00 40 00 00

	"This is the description string." (UTF-16)
	00 54 00 68 00 69
	00 73 00 20 00 69 00 73 00 20 00 74 00 68 00 65 00 20 00 64 00 65 00 73 00 63 00 72 00 69 00 70
	00 74 00 69 00 6f 00 6e 00 20 00 73 00 74 00 72 00 69 00 6e 00 67 00 2e

	00 00 00 10 66 00 00 00
	01 00 00 20 00 00 00 6e 4f a0 f0 c6 eb 2c 20 5b f3 09 19 73 5f 8e 39 ce 6a 75 1a 66 e1 35 de 92
	fd aa 1c 9f 16 df 43 00 00 00 00 0e 80 00 00 00 02 00 00 20 00 00 00 be 11 9b ea 58 88 c5 88 61
	21 86 d6 e3 32 63 14 be 59 64 79 49 eb 55 52 b8 d6 c9 c5 ad 0d 98 11 30 00 00 00 cb 4a b3 4e 61
	d0 45 80 ca cc 20 85 21 68 5b e9 6b bb a7 35 59 87 8d 70 df 9f 85 73 8a b5 74 36 d5 06 a8 d0 12
	f8 93 38 7f e3 32 fe 32 53 f9 bc 40 00 00 00 5a a4 2a c1 1c 54 b4 e8 af 8a bc 02 e1 cf 9e bd a8
	23 bd 05 65 13 e6 c5 dc 7d e5 a0 ba a3 c5 e3 57 da 67 a3 4b d3 35 f1 54 29 c6 c4 49 a3 c4 5b 37
	92 f8 27 d3 92 e5 f7 2a 00 15 30 c0 81 7a 3a 6b e5 a0 cb ee f0 3c 0b


0xbb010003 - write_psk_white_box (PSK WHITE BOX)
длина 102 байта
	fa
	d1 e5 b8 79 30 26 5d b0 ed 25 44 e3 61 50 56 f6 19 fc 11 e6 a5 58 f8 e0 d9 20 03 e4 79 ff 41 02
	ff 20 00 00 00 7d dc fc db a9 e8 1b 0c 48 15 63 8d 03 05 30 3b 56 2e 5f 40 14 f4 0b 9d 76 ed f2
	75 5d 9e 5d bd 86 94 b0 50 8d f7 86 19 3d ed df ca 48 54 fe f9 3f 68 a5 d5 cf de ec 15 24 29 05
	76 fd ad 0c 67


write 0xbb010002 [n] = read 0xbb010002 [n]
write 0xbb010003 [n] = read 0xbb020003 [32]


5. прочитать с помощью команды `0xe4`

0xbb010002 - read_sealed_psk (содержимое Goodix_Cache.bin)
	длина 332 байта
	01 00 00 00 d0 8c 9d df 01 15 d1 11 8c 7a 00 c0 4f c2 97 eb
	01 00 00 00 ce 4b 48 a6 19 9f e1 4c a7 a3 2e 7a 0e 0b 6b 59 04 00 00 00 40 00 00

	"This is the description string." (UTF-16)
	   00 54 00 68 00
	69 00 73 00 20 00 69 00 73 00 20 00 74 00 68 00 65 00 20 00 64 00 65 00 73 00 63 00 72 00 69 00
	70 00 74 00 69 00 6f 00 6e 00 20 00 73 00 74 00 72 00 69 00 6e 00 67 00 2e

	00 00 00 10 66 00 00
	00 01 00 00 20 00 00 00 d7 77 c2 10 c1 bc 73 d2 87 fb 57 99 53 16 39 0e 39 eb 6a d0 43 cd 08 19
	e0 82 a6 cb 14 8b 38 47 00 00 00 00 0e 80 00 00 00 02 00 00 20 00 00 00 e9 2d 13 48 1b e6 8b 22
	b5 b3 7a b3 9a 65 4b 3e 73 f6 6a a7 af 47 49 31 a6 4c 47 84 bd c4 32 f9 30 00 00 00 15 67 c9 fc
	68 79 ba 11 cc 3e fb 30 82 be 3a b7 1c 18 f9 cd ef 08 0d dc 1a b9 17 79 17 9b 79 42 73 1a b8 2d
	8e 31 b6 8a 0f b1 cb 3b 0c 83 15 8e 40 00 00 00 ee b8 30 22 43 74 f3 15 cf 0c 60 c9 c7 40 32 6f
	7e e7 99 f2 21 75 11 58 d2 71 59 33 66 ed a7 a3 43 66 12 5b e1 11 73 2a a3 59 83 1e 83 66 50 88
	f4 2c 6f c8 f7 5e 93 3d 07 c9 97 fc 05 f9 30 9c b6 a0 6b f1 a4 18 8a cf

0xbb020003 - read_psk_hash (он же PMK HASH)
	длина 45 (32) байта
	8d 8e 99 80 5d 1e 22 89 c5 41 12 5d 5a dd 5d d5 30 89 4c c8 50 0d 03 55 41 b8 c0 a5 96 1e c0 5d

	хешируем PSK или PSK WB
	psk_hash == Crypto.Hash.SHA256.SHA256Hash(PSK).digest()
	0000000000000000000000000000000000000000000000000000000000000000 = 66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925 SHA 256   64 rounds



