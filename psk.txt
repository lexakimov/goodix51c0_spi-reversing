Термины

PSK — предварительно общий ключ (Pre-Shared Key). В логах генерируется заново (32 байта), шифруется через DPAPI и используется драйвером как идентификатор в TLS‑профиле TLS-PSK-WITH-AES-128-GCM-SHA256; см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:684.
PMK — парный мастер‑ключ (Pairwise Master Key). В стекe Goodix это производное значение/хэш от PSK, которым MCU и хост проверяют синхронность секретов; видно по сообщениям вида “Enclave decrypted PMK” в других логах (logs_3/WBDI.log:5106).
MCU — микроконтроллер внутри модуля отпечатка, на который драйвер шлёт SPI‑команды вида production_read_mcu/production_write_mcu; пример диалога см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:213.
nav base — эталонный (базовый) образ для режима навигации по поверхности сенсора; запрашивается в процедуре gf_get_navbase, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:1110.
fdt base — эталонные данные для режима FDT; драйвер загружает их через gf_get_fdtbase, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:1071.
nav — режим сенсора, в котором он выдаёт специальные “navigation” кадры (для жестов/позиционирования); переключение на него видно в logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:1110.
fdt — набор процедур и данных для Finger Detection Template (обработка и анализ кадров для обнаружения пальца); инициализация показана строками FDT_Init и startfdtDataAnalyzeMonitoring в logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:41 и logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:526.
evk — строка версии прошивки MCU (Evk version) формата GF_HC460SEC_APP_xxxxx; запрос выполняется GetEvkVersion, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:179.
HDSC firmware — вспомогательная прошивка (High-Definition/Security Controller) для внутреннего контроллера Goodix; необходимость обновления отмечена в logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace.log:180.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
PSK (Pre-Shared Key - Предварительно разделенный ключ)

PMK (Pairwise Master Key - Попарный мастер-ключ)
	генерируется (часто выводится) из PSK.
	Сам по себе обычно не используется для шифрования данных напрямую.
	Вместо этого он служит основой для генерации других, более короткоживущих сеансовых ключей (например, PTK - Pairwise Transient Key).

TODO: понять алгоритм преобразования PSK(32) -> PSK WB(102)   - смотреть production_write_key в коде драйвера
TODO: понять алгоритм преобразования PSK WB(102) -> PSK WB HASH(32) при write 0xbb010003 -> read 0xbb020003
TODO: понять алгоритм генерации энтропии (48 байт)

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CODEX

Генерация PSK
- Драйвер получает криптоконтекст Windows, генерирует 8‑байтный seed и 32‑байтный PSK (CryptAcquireContext succeeded, Random sequence generated) (…:307-313).
- PSK шифруется через DPAPI: “seal psk” даёт 324-байтный blob, внутри которого виден GUID и строка описания This is the description string. (…:314,317,332,333).
- Дополнительно формируется блок типа 0xbb010003 (102 байта), оба TLV (332 байта + 102 байта) пакуются в сообщение длиной 0x1c4 и отправляются на MCU командой cmd0 0xe (…:319-323,330-344,360).
- После подтверждения от MCU кеш с ключом обновлён, драйвер фиксирует успех и сообщает update key success (…:360,374,377).

Повторная проверка
- Сразу после записи выполняется новый check psk: теперь Goodix_Cache.bin читается полностью (332 байта), blob расшифровывается (unseal return 0x0) и из него вычисляется хэш (…:385,389-396,398).
- Для сверки MCU отдаёт хэш по data_type 0xbb020003; устройство возвращает 40 байт данных без ошибок (…:402,414-428).
- Сравнение хэшей проходит успешно (!!!hash equal !!!, check psk: psk is valid!), процесс помечается как завершённый (…:432-436).
- Позже состояние MCU показывает psk_check_fail:0, что подтверждает синхронизацию ключа между хостом и контроллером (…:1057).

------------------------------------

1. Да, параметр entropy_len 48 явно указан драйвером как при шифровании (seal psk, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace_clear.log:314-317), так и при расшифровке (generate rootkey, inbuf_len 324, entropy_len 48, там же :389-392). Это подсказка, что в CryptProtectData/CryptUnprotectData используется дополнительная 48-байтовая «entropy» (скорее всего аппаратно-зависимая соль).
2. GUID и строка описания видны в выгружаемых по SPI байтах того же блока: строки write 456 показывают UTF-16-LE текст This is the description string. внутри TLV, см. logs_2/_logs_0_init_1_psk/WBDI_spbProbeTrace_clear.log:332-336. Непосредственно перед текстом лежит структура DPAPI с GUID’ом (d0 8c 9d df ...).
3. TLV — это формат «Type-Length-Value»: 4-байтовый идентификатор типа, 4-байтовая длина полезной нагрузки и затем сами данные. В посылке на MCU сначала идёт TLV 0xbb010002 (332 байта), далее TLV 0xbb010003 (102 байта), что видно по последовательности в тех же строках :329-357.
4. Блок 0xbb010003 появляется после шага process encrypted psk (process ret 0x0 type 0xbb010003, length before 32, length after:102, :318-319). При повторной проверке та же структура восстанавливается из файла как результат .wb data (wb return 0x0 length before 32, length after:102, :393-394), а затем из 102 байт вычисляется 32-байтовый хэш (.hash ... length after:32, :395-396). MCU читает этот хэш своим запросом 0xbb020003 и выдаёт 40 байт (заголовок + 32 байта значения, :402-419). Поэтому запись 0xbb010003 определяет, что MCU сохранит и вернёт при чтении 0xbb020003: если 102-байтовый блок другой, MCU-сохраняемый хэш меняется, и сравнение (шаг 3.verify) даст расхождение.
5. DPAPI используется только для хранения ключа на стороне хоста: seal psk шифрует 32-байтовый PSK перед записью в Goodix_Cache.bin, а unseal return 0x0 возвращает его в чистом виде (32 байта, :392). После расшифровки драйвер сразу делает .wb data/.hash, а затем запускает TLS (TLS Init Success, :647). Это означает, что полученный plaintext-PSK подается в mbedTLS (вероятно через mbedtls_ssl_conf_psk), а параллельно через TLV 0xbb010003 передаётся MCU. Контроллер, получив этот блок, обновляет свою копию ключевого материала и выдаёт согласованный хэш через 0xbb020003, так что обе стороны используют один и тот же PSK в последующем рукопожатии TLS-PSK.

но ведь длина bb010003 102 байта, а не 32. То есть PSK передается не в открытом виде? что значит .wb data и .hash ?

Блок 0xbb010003 действительно 102 байта. Это результат шага production_get_host_psk_data: на вход подаются 32 байта «чистого» PSK, на выход — структура большего размера.
Она содержит сам PSK (он лежит в первых 32 байтах) плюс добавочные поля/метаданные, которые Goodix добавляет перед отправкой на MCU.
То есть ключ в итоге уходит на устройство не только в DPAPI-обёртке из 0xbb010002, но и в практически открытом виде внутри 0xbb010003.

Лог Goodix>>> .wb data относится к функции production_get_host_psk_data (см. строки ...production_get_host_psk_data:02827). По сообщениям видно, что на вход она получает 32 байта и расширяет их до 102 (length before 32, length after:102). Судя по названию, это «white-box data»/«wrap blob» — упаковка ключа вместе с дополнительной служебной информацией для ПО/MCU.
Следующий шаг Goodix>>> .hash берёт эти 102 байта и считает по ним 32-байтовый хэш (length after:32). Именно этот хэш позже сравнивают с тем, что выдаёт контроллер по запросу 0xbb020003, чтобы убедиться, что хост и MCU синхронизировали один и тот же PSK.
Если хочется убедиться в присутствии самого ключа в блоке — можно посмотреть первые 32 байта полезной нагрузки 0xbb010003 (например, по логу: fa d1 e5 b8 79 30 26 5d ...). Они и являются тем самым PSK, а оставшиеся ~70 байт — служебные данные, позволяющие драйверу и MCU согласованно его хранить и валидировать.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Расшифровка:
Прямой путь — на Windows использовать CryptUnprotectData, передав бинарный blob и ту же энтропию.
Примеры:
    PowerShell: [System.Security.Cryptography.ProtectedData]::Unprotect($blob, $entropy, 'CurrentUser').
    Python с pywin32: win32crypt.CryptUnprotectData(blob, None, entropy, None, None, 0).

Если доступа к исходной системе нет, остаётся brute-force DPAPI через резервные ключи домена/DPAPI master key
(инструменты вроде mimikatz dpapi::masterkey или dpapick) — без них расшифровать нельзя, т.к. DPAPI использует AES‑256 с ключами, зависящими от SID пользователя и мастер‑ключей Windows.

После CryptUnprotectData вы получите исходный 32‑байтовый PSK, который далее используется как ввод для хэширования и TLS‑PSK‑handshake.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

1. генерим PSK - 32 байта
2. шифруем PSK в gf_seal_data через CryptProtectData - на выходе 324 байта (это sealed_psk (0xbb010002), хранится в Goodix_Cache.bin (332 байта))
3. преобразуем PSK в PSK WB (0xbb010003) через функцию production_write_key - на выходе 102 байта
4. записываем 0xbb010002 и 0xbb010003 с помощью команды `0xe0` - 452 байта
5. прочитать 0xbb010002 с помощью команды `0xe4`

хешируем PSK или PSK WB
psk_hash == Crypto.Hash.SHA256.SHA256Hash(PSK).digest()
0000000000000000000000000000000000000000000000000000000000000000 = 66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925 SHA 256   64 rounds
